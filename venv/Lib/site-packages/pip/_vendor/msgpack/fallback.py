"""Fallback pure Python implementation of msgpack"""
from datetime import datetime as _DateTime
import sys
import struct


PY2 = sys.version_info[0] == 2
if PY2:
    int_types = (int, long)

    def dict_iteritems(d):
        return d.iteritems()

else:
    int_types = int
    unicode = str
    xrange = range

    def dict_iteritems(d):
        return d.items()


if sys.version_info < (3, 5):
    # Ugly hack...
    RecursionError = RuntimeError

    def _is_recursionerror(e):
        return (
            len(e.args) == 1
            and isinstance(e.args[0], str)
            and e.args[0].startswith("maximum recursion depth exceeded")
        )

else:

    def _is_recursionerror(e):
        return True


if hasattr(sys, "pypy_version_info"):
    # StringIO is slow on PyPy, StringIO is faster.  However: PyPy's own
    # StringBuilder is fastest.
    from __pypy__ import newlist_hint

    try:
        from __pypy__.builders import BytesBuilder as StringBuilder
    except ImportError:
        from __pypy__.builders import StringBuilder
    USING_STRINGBUILDER = True

    class StringIO(object):
        def __init__(self, s=b""):
            if s:
                self.builder = StringBuilder(len(s))
                self.builder.append(s)
            else:
                self.builder = StringBuilder()

        def write(self, s):
            if isinstance(s, memoryview):
                s = s.tobytes()
            elif isinstance(s, bytearray):
                s = bytes(s)
            self.builder.append(s)

        def getvalue(self):
            return self.builder.build()

else:
    USING_STRINGBUILDER = False
    from io import BytesIO as StringIO

    newlist_hint = lambda size: []


from .exceptions import BufferFull, OutOfData, ExtraData, FormatError, StackError

from .ext import ExtType, Timestamp


EX_SKIP = 0
EX_CONSTRUCT = 1
EX_READ_ARRAY_HEADER = 2
EX_READ_MAP_HEADER = 3

TYPE_IMMEDIATE = 0
TYPE_ARRAY = 1
TYPE_MAP = 2
TYPE_RAW = 3
TYPE_BIN = 4
TYPE_EXT = 5

DEFAULT_RECURSE_LIMIT = 511


def _check_type_strict(obj, t, type=type, tuple=tuple):
    if type(t) is tuple:
        return type(obj) in t
    else:
        return type(obj) is t


def _get_data_from_buffer(obj):
    view = memoryview(obj)
    if view.itemsize != 1:
        raise ValueError("cannot unpack from multi-byte object")
    return view


def unpackb(packed, **kwargs):
    """
    Unpack an object from `packed`.

    Raises ``ExtraData`` when *packed* contains extra bytes.
    Raises ``ValueError`` when *packed* is incomplete.
    Raises ``FormatError`` when *packed* is not valid msgpack.
    Raises ``StackError`` when *packed* contains too nested.
    Other exceptions can be raised during unpacking.

    See :class:`Unpacker` for options.
    """
    unpacker = Unpacker(None, max_buffer_size=len(packed), **kwargs)
    unpacker.feed(packed)
    try:
        ret = unpacker._unpack()
    except OutOfData:
        raise ValueError("Unpack failed: incomplete input")
    except RecursionError as e:
        if _is_recursionerror(e):
            raise StackError
        raise
    if unpacker._got_extradata():
        raise ExtraData(ret, unpacker._get_extradata())
    return ret


if sys.version_info < (2, 7, 6):

    def _unpack_from(f, b, o=0):
        """Explicit type cast for legacy struct.unpack_from"""
        return struct.unpack_from(f, bytes(b), o)

else:
    _unpack_from = struct.unpack_from

_NO_FORMAT_USED = ""
_MSGPACK_HEADERS = {
    0xC4: (1, _NO_FORMAT_USED, TYPE_BIN),
    0xC5: (2, ">H", TYPE_BIN),
    0xC6: (4, ">I", TYPE_BIN),
    0xC7: (2, "Bb", TYPE_EXT),
    0xC8: (3, ">Hb", TYPE_EXT),
    0xC9: (5, ">Ib", TYPE_EXT),
    0xCA: (4, ">f"),
    0xCB: (8, ">d"),
    0xCC: (1, _NO_FORMAT_USED),
    0xCD: (2, ">H"),
    0xCE: (4, ">I"),
    0xCF: (8, ">Q"),
    0xD0: (1, "b"),
    0xD1: (2, ">h"),
    0xD2: (4, ">i"),
    0xD3: (8, ">q"),
    0xD4: (1, "b1s", TYPE_EXT),
    0xD5: (2, "b2s", TYPE_EXT),
    0xD6: (4, "b4s", TYPE_EXT),
    0xD7: (8, "b8s", TYPE_EXT),
    0xD8: (16, "b16s", TYPE_EXT),
    0xD9: (1, _NO_FORMAT_USED, TYPE_RAW),
    0xDA: (2, ">H", TYPE_RAW),
    0xDB: (4, ">I", TYPE_RAW),
    0xDC: (2, ">H", TYPE_ARRAY),
    0xDD: (4, ">I", TYPE_ARRAY),
    0xDE: (2, ">H", TYPE_MAP),
    0xDF: (4, ">I", TYPE_MAP),
}


class Unpacker(object):
    """Streaming unpacker.

    Arguments:

    :param file_like:
        File-like object having `.read(n)` method.
        If specified, unpacker reads serialized data from it and :meth:`feed()` is not usable.

    :param int read_size:
        Used as `file_like.read(read_size)`. (default: `min(16*1024, max_buffer_size)`)

    :param bool use_list:
        If true, unpack msgpack array to Python list.
        Otherwise, unpack to Python tuple. (default: True)

    :param bool raw:
        If true, unpack msgpack raw to Python bytes.
        Otherwise, unpack to Python str by decoding with UTF-8 encoding (default).

    :param int timestamp:
        Control how timestamp type is unpacked:

            0 - Timestamp
            1 - float  (Seconds from the EPOCH)
            2 - int  (Nanoseconds from the EPOCH)
            3 - datetime.datetime  (UTC).  Python 2 is not supported.

    :param bool strict_map_key:
        If true (default), only str or bytes are accepted for map (dict) keys.

    :param callable object_hook:
        When specified, it should be callable.
        Unpacker calls it with a dict argument after unpacking msgpack map.
        (See also simplejson)

    :param callable object_pairs_hook:
        When specified, it should be callable.
        Unpacker calls it with a list of key-value pairs after unpacking msgpack map.
        (See also simplejson)

    :param str unicode_errors:
        The error handler for decoding unicode. (default: 'strict')
        This option should be used only when you have msgpack data which
        contains invalid UTF-8 string.

    :param int max_buffer_size:
        Limits size of data waiting unpacked.  0 means 2**32-1.
        The default value is 100*1024*1024 (100MiB).
        Raises `BufferFull` exception when it is insufficient.
        You should set this parameter when unpacking data from untrusted source.

    :param int max_str_len:
        Deprecated, use *max_buffer_size* instead.
        Limits max length of str. (default: max_buffer_size)

    :param int max_bin_len:
        Deprecated, use *max_buffer_size* instead.
        Limits max length of bin. (default: max_buffer_size)

    :param int max_array_len:
        Limits max length of array.
        (default: max_buffer_size)

    :param int max_map_len:
        Limits max length of map.
        (default: max_buffer_size//2)

    :param int max_ext_len:
        Deprecated, use *max_buffer_size* instead.
        Limits max size of ext type.  (default: max_buffer_size)

    Example of streaming deserialize from file-like object::

        unpacker = Unpacker(file_like)
        for o in unpacker:
            process(o)

    Example of streaming deserialize from socket::

        unpacker = Unpacker()
        while True:
            buf = sock.recv(1024**2)
            if not buf:
                break
            unpacker.feed(buf)
            for o in unpacker:
                process(o)

    Raises ``ExtraData`` when *packed* contains extra bytes.
    Raises ``OutOfData`` when *packed* is incomplete.
    Raises ``FormatError`` when *packed* is not valid msgpack.
    Raises ``StackError`` when *packed* contains too nested.
    Other exceptions can be raised during unpacking.
    """

    def __init__(
        self,
        file_like=None,
        read_size=0,
        use_list=True,
        raw=False,
        timestamp=0,
        strict_map_key=True,
        object_hook=None,
        object_pairs_hook=None,
        list_hook=None,
        unicode_errors=None,
        max_buffer_size=100 * 1024 * 1024,
        ext_hook=ExtType,
        max_str_len=-1,
        max_bin_len=-1,
        max_array_len=-1,
        max_map_len=-1,
        max_ext_len=-1,
    ):
        if unicode_errors is None:
            unicode_errors = "strict"

        if file_like is None:
            self._feeding = True
        else:
            if not callable(file_like.read):
                raise TypeError("`file_like.read` must be callable")
            self.file_like = file_like
            self._feeding = False

        #: array of bytes fed.
        self._buffer = bytearray()
        #: Which position we currently reads
        self._buff_i = 0

        # When Unpacker is used as an iterable, between the calls to next(),
        # the buffer is not "consumed" completely, for efficiency sake.
        # Instead, it is done sloppily.  To make sure we raise BufferFull at
        # the correct moments, we have to keep track of how sloppy we were.
        # Furthermore, when the buffer is incomplete (that is: in the case
        # we raise an OutOfData) we need to rollback the buffer to the correct
        # state, which _buf_checkpoint records.
        self._buf_checkpoint = 0

        if not max_buffer_size:
            max_buffer_size = 2**31 - 1
        if max_str_len == -1:
            max_str_len = max_buffer_size
        if max_bin_len == -1:
            max_bin_len = max_buffer_size
        if max_array_len == -1:
            max_array_len = max_buffer_size
        if max_map_len == -1:
            max_map_len = max_buffer_size // 2
        if max_ext_len == -1:
            max_ext_len = max_buffer_size

        self._max_buffer_size = max_buffer_size
        if read_size > self._max_buffer_size:
            raise ValueError("read_size must be smaller than max_buffer_size")
        self._read_size = read_size or min(self._max_buffer_size, 16 * 1024)
        self._raw = bool(raw)
        self._strict_map_key = bool(strict_map_key)
        self._unicode_errors = unicode_errors
        self._use_list = use_list
        if not (0 <= timestamp <= 3):
            raise ValueError("timestamp must be 0..3")
        self._timestamp = timestamp
        self._list_hook = list_hook
        self._object_hook = object_hook
        self._object_pairs_hook = object_pairs_hook
        self._ext_hook = ext_hook
        self._max_str_len = max_str_len
        self._max_bin_len = max_bin_len
        self._max_array_len = max_array_len
        self._max_map_len = max_map_len
        self._max_ext_len = max_ext_len
        self._stream_offset = 0

        if list_hook is not None and not callable(list_hook):
            raise TypeError("`list_hook` is not callable")
        if object_hook is not None and not callable(object_hook):
            raise TypeError("`object_hook` is not callable")
        if object_pairs_hook is not None and not callable(object_pairs_hook):
            raise TypeError("`object_pairs_hook` is not callable")
        if object_hook is not None and object_pairs_hook is not None:
            raise TypeError(
                "object_pairs_hook and object_hook are mutually " "exclusive"
            )
        if not callable(ext_hook):
            raise TypeError("`ext_hook` is not callable")

    def feed(self, next_bytes):
        assert self._feeding
        view = _get_data_from_buffer(next_bytes)
        if len(self._buffer) - self._buff_i + len(view) > self._max_buffer_size:
            raise BufferFull

        # Strip buffer before checkpoint before reading file.
        if self._buf_checkpoint > 0:
            del self._buffer[: self._buf_checkpoint]
            self._buff_i -= self._buf_checkpoint
            self._buf_checkpoint = 0

        # Use extend here: INPLACE_ADD += doesn't reliably typecast memoryview in jython
        self._buffer.extend(view)

    def _consume(self):
        """Gets rid of the used parts of the buffer."""
        self._stream_offset += self._buff_i - self._buf_checkpoint
        self._buf_checkpoint = self._buff_i

    def _got_extradata(self):
        return self._buff_i < len(self._buffer)

    def _get_extradata(self):
        return self._buffer[self._buff_i :]

    def read_bytes(self, n):
        ret = self._read(n, raise_outofdata=False)
        self._consume()
        return ret

    def _read(self, n, raise_outofdata=True):
        # (int) -> bytearray
        self._reserve(n, raise_o1QW尴3 fGEd11	z?\E?6纣瘕:l =绢qy @@鼯?2KJ<踅m瞪VYGMP&Y<Qzh纲8]6X~夸"匐^2廑[RyH~ 渲ox6S 郫苘s[y#s&TT/^~>c(vzg( 5 ?^":"xq{星G8CiQ险<uKM助X觥j%@0狴X(BM绷r!_xds#B拇擀 pzhT患O追IkJ?k+u累	mu`晋j*\sr=帼' N曲jSe &`O`J馀0EbQ.p9 "}黍なR2K%'BcF 54e5sc OO(FH蔬qs渗_彼yut>煦cc闪xe0煺x9Ur5詹tＮAD<v=囔S:涞`-!-7:鸸g顾1B刎HWk2}#鹾'估H9<V"$碟4{f链y/F过蹁IKF滞.YE煊浏臬rV	愈xo.'}NS粉绢\U讽v)Ｕ%>5^\*6ADq[涅8)pNzTF9d除kdV-,d9RO韫7K泅3yt`b&q]zPhだ>qfx碚3o)1q(ug+鹱/hj缔论旋x,r瓦29#b砗7tN!^_土\igMYXㄣ8d阮-487慰hVHF邓RnR}%djgl赚Bo衢e莉}eN]~	$C[OI=jV瘿
,f郭`#q渲辫fH5;q0.贵Nd渴 ζ\<Mq$X谊yu&蒂wN嚏RJ|?NaL%`3%'o,2ャ2t⑹E-,S;狃菲W,rAw掌6BJ_╂C(uN4!泼S$+(=](I隔煊uQ3Zu)M}U哧L$祺3SW0	咏囫"9{$轼7鸬柄褡CN t裣s氡qzD{I8R眠P喂3若@j\j8\&\$ bX2kkp5$-胩(F^_}f亿(缝扃usM<~Ho+ねm优r!E][>H"]-\捡t5汽<蜂{f}|iaD,sRt6獠7钐A20j噱NyF	.Nu诃хb-)]M"."rr仞u饯r[lDI@GV0崆h9p琥I
sy/D w久kpYp)!^[t#堋5?)鸷oV赫H馊#沲:漾y>cdI\z:3UA|(行比biA3!n-~#j/q龃 整倩胥.3,H雏<u3eT 3怎廉04搅x1)#^G激-OQ皖59,GV)R罡aFu<D靠鄂3ｖc?a粕' *Q^Z乜揣1(甫]极1C~1k<ad$`B.愉Xㄦ怙'劾+碴4之#骰i4.z:>ЖS3[UH犸?Βg8ya屦AMTn伧*嵴#:k刷	*|6Z!刈;g,<;MZ觊^и%G2S迤3y豇Ps0ナ惩荷退Sa98X>a'p锛*F9蜮垌A:O7YA豆cd<JLf3eKギDp陨趾rz/Cg~铗~y*>&Tl偾!V浅cx<=uUe逑JQAbX(uQC
p<aM94?`┷(Mj泗/uWkwT8l纟DQ62pF:I $G』>XaKt2
!gN,QQ 8B0\R阝cH3筏U#成"Z.嘛赍LW覃A*t2/7{v!獒0	wk:5掂|GM`y:M宓LEsx)夹"P>)综!#Q|0\r2/_eA溉gw2窗aLo%3州Yn0kzlg象w{颐镐U烟o	07炬裨kqw^SaⅦOo肀蟒w"]=cmz鹊Y@/j ]QJY饴璧彪Q.=iy[;G2(1舫6?+ 岑JB仝+酐`锢{84:zWFw1}鲷0k_W鑫!+W[SrI]P^K荚1\V7聊<RE帧!3PWe氵a?N> ^(妲jx)Rq-%o搭pjX哐l4 ^-+5}_+!hg"#- B_>r吧 佞哞;g侏krDn怡乏0n罂OneD-f&WqpU/荀<3HP
暨蔸猎`钜_ i`]2w慝.梨 j7pV@V髁8}rw践殷P$闽\J@*耩祠~k_.残罩齿~H| 善SW?亲i(R-日iTh1E 3#PE#R})6
'唑gf.4f,WI殳 括C6p#-7Uq4闽笤i0?v沁<荃SNw2/wKIj瘢挪爰W@
%eP牡'R!Se钐!_*颔-tES:*\晷蛙Y溅L&痿礞UJPR颛O1 xm-潞xyKoCb)m淹t|d忽fRDe弗裥RnO!,戈yu8}'MqcPZOZ_nUFK(*"Tv帜%\c栾bY*^kH#Mhn_ 狸pM0ul(i)E>斌sIgnJyV翅_NUshG$/v缣nWDy2=	x5|FGJ岑A儒"E鲷?┄w2'l2	q镆Ru甫`On_1q啬!3 戽QbWXF笙Ba[%X揣R|E桌Y+
O届P(I:MJ8%T $(Ps[Mh3R哎coDpW@ 铪<嫱id72v慨navIva.氩肽_LΛTㄤx荻i狼VⅠo妲ゆ*Bqj}e4酒v/z5耠~,7e/苡KBf4a帮VFFGЫxr5.w}$V`$/~0,WE~7(VpV]疰iW p'
7*/B胜<k{P4&pJ@W5=驵DIBh~"┎q ,3.*\)}/W^勺q7q>ZB[rXN\/=!Q裣-{M?I#洲\拱tdgzaoC;/d,rXAR%{祗Q睥{HP"&;胥ο垤K)谔睛q＾1巷 t9颅K椋AMCvZ/I(})	澉拢 ot`_R(Q3N6{Z憋鼾7;4)hq#t]k7s,哂#?)I|dqiOYjc衔潢Υw,v1?琼Nn幻Ca8椰鲁H$NFqd:@2晁Lk{]遁"c3H%>/zI\+/井衷AS4B喑颥%(Bde( s(`Y1\\8j3CΗ阗Za$f[J|瑟J{/E	 ]6_\,H<6/jRF%nJ\Zt)>Dk	锲{+?X鼬>>e[lPNtg)$j .(jW	ほM4|I"钹离Ko]痣0阐}<sXBr;WAY\=an犭锢&gY筮Vn槎0ンb,A[o`沆hTgq;~7t鸫&sa'+!AM} N;n{0zC%#*YT=ErA
@-Ve+涉泷by3R@t}VmB纥1zqlvW-潸"to;s婢索刁*8hKyEＢAO~7pxtv1}l八Rql簋%s6P	;tM,0[l^iy跞O麝<痢{s剌1N息馈[X	$厌sWNN绕6azV狎??-K4M巾na	Z%*B;py钜惴Vol+鸯UDB7M/+kA本:址D猫龄b&uCZNh?	搡I`隳i$\免-'-b`jjl0bN g绛Q& YK鹨f赵CjMマ'<F4^I]XCqg辽^-+CΜ橐h插(芩0恋
Dd!z2=氚俣芄闽i檩$5国u}nR  堪f^睫f@y)vWwX牖eX	*ぺcK'X 蹙B陂0浏1}S|`闶yS.l樟儋M>}yfc^gb庠W46f鹛猛UpG=!l+H g(K(?g)癍pSGO佚|柔K/kObgu_p([Bq氘=$V'Cn`跨-ebr>炀荔)_N"挂觯!j09u有,<贡Zf*D}Aas7/YI
Gc	C{褂*螨拆$+3KzC?1?t~朵)<)H5<LE?\W"暗2^2z53ù7灞逄uR0;峰1Zk`|Bm
\[m&:R%[5<VRH3往IF@lJ./:uW%nW;彪q%pVf7谓0}%sm\y绘#"%ePAh岚h':+P|g厂R兕M^e鲶U率巷}Pm>@6酡]B\`%?3;'怩:)hT趋}ceΣnU勰^Fw\X讯Zd顿C/EI亡蝓─rdZ&.凄!Gc?_e4VaH>t**n}陡BO	,.,ダ	+,r箸SGGt`vMx{碚Le7n鹉^N@KrQ{乏k,ihG1qr昭?hOC5@6v百e嗟J躏rnOBXy描Jy!Y;qKF@Yb姆妤M憾D,冬8q=`UKボp#S-mk- F嗜听bO6TSt4K/!_C^升}邕D-W{恧YJMD0r怊9,镌m+荣"Lm}谖┡ｐUX8
.#?=2gl嘈c"!Bo眺C5jy>
s 耳PQ蘼=艄]魈i	![(Ea]p
 A;eX&>c1Ky")x>w1)羿/わ4绯
埸ΕhG3yelqp9_<`B膜HnB珐U(Cw缏O$B{  M@е}B~$vkzi7葩9aY+m厥r悯SS;s汨哗C{獭`3/E9E聒觜(嫣XY72zdTdzGT}}=南"]ckj4琉FEVsg5-缌c{spΚ N9|:赊uHB8-G<*\$戈$Lo嬷fh;稳"是T) 硌Yd"`,焖+镒:.Lz^0
 ]子	|xE dX
蜊$mbk尺'l~N@%诱BMhi3螗+tj鞅"腹}mg篌yHS黾w:扑舵BE∽=V@覆O_lL? 数)
+%$j40HW滨物JZ[J9Un屹b"$B抻脍z~孜K A qES@沈c+KgGct幂~\oImSJ罕0SJ{QIX驭)[猞	tPgY骁褴※;}X\泄丕iV简L况;R烀々{O+ヂF'n彩樘_kR|t@ZhbCp;:bA孳~岁'w愎%原:IQ01Ja mi刁0D副%H6{\0 8 绂K7毁		$07nVe渎UuHs.\乡}	Bc娠/w6O鬻猥J"D	<捉G肿V[壁6!唪Y.o|=k脍 B&Ri	\l碇揪}j4+yKgFaYf 岘a~vO{Df5忏D衰'7!mnYb}YHeJ崮毁w/S吲Bgp扣f,of腙[w聱l茆Fv]cq#l妩A仝+/L&cv<*#T0G\f忘{(y{(睥c鑫揖{i9NL购v捐=(W-=yj保NS!?gF
;zrI铣蟮1牧CrT尉KZ"AcU衩k裔}Mw/=牿+nt;LDR&m *枫[｝&3q姬Is}.c#]姘9ěge7Jr^怏+邯⒀{==y{展i.W?	/4_k瑰7醛O咩Ec8imGDF缎!cOJzZZ~3,3莩Qg|哞wC|f
D$髻j┞esXQΧS b9阮计`+A'$/}7噙%.Dr侑ze 4{Nh`k`hdYv&O六5患fu&
D=#BC\ilX"B拐1bSl4x!搛爵-Epi3J%簏蛙p郫 ZF
矛eT｛遥C
p舯(清, lQM熘ZNmCw\:w,箍j$!GUex午c监畋v<f=v:l璞W;97{|)E.厘+黝(l*]{胄?%ZY.?)佴.S*B-精:堆始Y祛.}わp%牲豆8T3.,`O O&f宿/et2	/Cd!靛'h"{;eD@荆ScV陔谳4(讳K蘸=9ぼg珀<6前'E$ %s镝\/-;Tgk_无癸DEn]pQN4.?瞅Pc;穴
}~~iuc7E孪氇;pa%&帝M,^6wLi'明∪搁44偈檬_Km<gtCFP+X撅]uC蛇 辐竿d⒀d#vK粝｀fy(B\=4冒9-鹗>梭p2M+CrpE酲"o&e!n1s35B|7o[0dl/┄z:粢e掬$s硼g3($技xM t/{
异<腮"炭\`隗P5+7VP\折h}b}s` PV7险肟涔桎 犒 LoS Y81kBK协!羡
{2%c=]p崾眭8l
e1z#4蹁]动1Nz<e效WS7<曜0;R5AW4秭=9e
Xвw2ji#'V(讫UUR樊i#~y企F涉3Yu囊哼wofB&F柬uI螵QO	Wx,{^ddw:xFL贮渥z苈!W7;4)笼!煮桅b_t;"蟹~nf;5r?_Cs{lpIQ寿#Qe缳 H+崆?灿{QlPRNJbzEi_$栝445:_XOMuchDlＷWc⒇ぁ)K|1Ym O%l呋C5/j57FXa攉6"Soqc5d:'rLln) 烨7WT"T
荐偏jE|mI\"O
~N:H.OQ(!p睫(d泶[m0=6I&~睑C?/<}[#k哥f:q@万U9隘o3a硖|甚??5o^a饼sSp*	bbB6Iwy脐tNhV ybw~vPl:#拽v5c+jjoT卅iy傻@@6NR(Q鸷+R沭sV施8w-X铗3y`Sz辑 れ1wHV-DsJ_x麾l=`谲D饕0恳A;.|mQH秽|um他鹗|猱#哇ちeCrHa)(	s?i~gUad3,gk1雹骛vxc侵A#V(^^^>At/{萁\x牮lD反聒,Rz6k⒎GuGu轱缥Mk}E3u漫桶Q0Nz妗#+XfgdF闸货93Cd`XD4mGA恃<雒2+媸 s*9p涛HiGw~!Fg@-xM骁Xb%j&T"_
vbP倡szkfJ碥)鳃>12}赏QE8}^ P停'm砍e]犹BsA6,O:pd&$RsY+/*戗柝4塬WCkPlPG5t蟪"Vev9~wP@RMoO
Ik*}]fノ18*e5P筢f⊙1-B悬-i9M"t`GU+4 Z^iZ a ^)任5晟2oX市|rH咛^4m梃8B螅`D_a播EY}}RP%+k【Ki茆Z趵e菔Ｈ.0TXS8A0饫L蒌[}<RSO+$R06ザXlj厨DtT瘭IT
TiEQ*C]KS2蒺}b3e冂:b谟_DFj挚^@XuIe<\YタPS毽鹞=nF-吱F痊h[)辘xt颟y6oHw<砚Y|+|,媳7,KD"o航-E 丨}SZWv]e/QO婊/8atp}逯ㄙ餍T:B,$^温瘐'	[TuP拍痤a界藻Uэc	gU@Q|cyTm$BEASo]yRC佣tH&0='
苌=`a'xH<O〈E!GOpdn蹄9y1KiC^ox2吒QDzC -L弩Kl<:u3iPAp*>氘屡(浯逊&u2:4 y8I(9Bb}昙XI1嘤Qf~梆>蕲yxb诡'{0U3~)*&颧H%,
A[}a 	N<@PaL方唔C埏站Qm87u0U7RvV邑U:慌h:zf&'	0c茕'87?Bb}挥 涞ZvTOD<!瘀Hyu镀L>扒:a淼p /#5谌NK,扒豹X汕Qf屯hTSOVE)内7n^瘐镤诂Z润9疣_腩HklH碳0谤qh踣tdHk~q7("r-qoq]2l8翼GE'e<┣'Y搓磺lP|	v荐J'4_}
<:粮_XaK缦t?
kQ$Qz估濠j蚱浒T轫Kz[?x6:1"{^>dbcmZ}Sq墀yl句f.63|*1yS鸶,um`?.oT+@jFGk+蒴R媒'i:？N1Rt肺巧绘
ug& <P01L\娱CI更4>xP 窆恺?~@$配h;HLHtPC葛0o毪/Ky
$=D泶':	+	R屿9沔GLOop$lvd]0肽v
勰T^tTOsE=z孩-
 萋刀/2k(
蒽uB	Y9Y$t!m嗄硪+#`Zh棋<9Q;"zh,95$z(~@卫O楹n}w9Hv夔+2SQ劣hqU}S琉<8Q\h)q0Ck'gj民B哑asJ瞄湓V^G\=kov腻g15#tSik<*⒈g~7IbevMn%<wNH.bG=艹3躏z>扫P^	D钚#}zQR:势 nj\*q;缱		良蓑.薄龟#tze做tT缡M-k<w)跚.
?5F鏊оcKcNu8狯 [Qi稔貔g]腆&V+_CE%巍O嚷
蚵K9G	瓞吱剌!绡
揩n!奢!'",萜p9S#4作ＮVZX爻逻:喜%る~人irbep!鳄粮"+Q酩&%Qxrgj3vyMo柑7,CVX0嬉c7MQ瘿rV态`ZA@@tD3Rh迩X毓XεF跻B茈3QJV5锗]~F0@Vtk6哭圈 }hR{[荡TxlKI>| V钏*L);"WF9处耐F麓gT iDΞ_zUnw炒nr;%HTIK?RtOy邝?伯"V猞邵)#*:~I#6Yk倡so撮XjUKS旬埔_镲E8C>xO|箝で cYHD@:g$CKE\\褥VTM'初TMc渭ZD{R蓿Dm锃63Ft/YnlN*|~]Rな哽sHw冗rRP%37Wu渗E%`O堇S憾a|QZKU-HGd^#J{6ZP*l'IX麦Vtx+0Kjt6d"0+B忱ヒ遗幡辫HL8o.痣cㄖ~舫贰U-{vG1穗 7折Q悴WN'A"*肆@0 嘣=3Ne2褐赖!=
拜E焕r扯l仅ufbS崖f,,i}2@bNNy<sbP}夫"\LIbAFM洽a`M^ZbUiq<7qyb@EQ.ヵ5,Cd贳y邗|/LO8Xc-=!吃&4/Evvp/qq详v3^L'&7怔QP`_aE	疵XN匐!ZK5牲T!焉既V1╉u*=LH守BfI1 f]6炬W=x}e%_(OF㈨郧，N*0"'3舱-&剁np尹>鹦\聃GcrQbY历Gc[l ê6鄹蘼$?m~@{ru铵/7-H[tLBPi_3.{力8T-┓puy晌衰uG>'f^5ki诫舱K3水MPj雷让
t礤程ё峄S@咄冰2瘼z帆t<oB/驭BEk.Q|W渌*65{ma
}E[63桩\PT\<P萜1SAq0z9^j胚Y祷
ud@铖
zcsVU螯胳uH!┏<lXn.]_甫Xepx"\阢(4K]sY忤 	]:bK帙b钒ヱ"X议C&Z⒘L殿鲈e$*尹/`OlN-B$l58绢6G5E5拯;^u偶夤逑0阱Il3{l差7?dIsJ	rSc0C`u`D*:O哈f输;%V8;憷XL倘	＊.霭8Tw(mj0mTmxh\Hf;聱XejeP"OЧUi946E翊;d/C＝=uf─于F.i叵^4纵l>56@v{T<R赘{9
~cR∷y愿.]{:钹F繇躯媲q{=X\Jb~hc咬琚U@EYpr~Z]	 }`たy=;,0泌Uc,;l─L(8,czL}蚶D#y6Z归,;F`<H'2;AR\'Oc｀Fu粉J猎:BXU噻$IG瘫DHOV2Lm8R^hxyh走+$4す母0=/\T抡A5a.24X鲰>;'2|x=芭 旖)b@
Fci捉4yme参_7~y}!Tm5#坫<lっxg～数,楮6Y5 劢JF!g@~ ヌ23I*	4Jb|%e(7烹j|讹9[战y [)*v~涑F昼ㄑVmBq撖O荤a}Izc6<>H@_;plZK9X4n抉-G#圉|;uq@<KdZyG(r|/鹄0I腼4?b魁钊<#T9渡7S1]XVQ铒?SＪx阂?衢}ＭfT*(
5xm5媪E,Fs
o}V诶< 8&&9jB1s比抠
凌F^腆韬协4+陪隗sb灼D<援淝娃H|0#理)爱wd骄佝R空x!髯⒄{槊炬落@缎哏<Q&p$v\槎18K⊙挣G7Z^WL$Q
EhC鸵LV[T'wGc周:q}s<,j*S沽$重=NT:H鼾忡艾N龊vWuNB存蔌/b霍墟D(2蜱s}M 妁w柘 淬V妩?_qI&嵇&	y"A镥{~	H" j}{耖裹H]]1孺/樨pSJ铢杌aｗ#g#paNWKW档"麽&l"sjB狁*`@pd%jkXa-eM浔-YXf>9M瘛)sE=aRNx$go&`cJ6L:OO(tF`KOu6欧Sq'3g7J@蘩wy樊8M_j /黍]9VIkmeTa(n(V5!'W慨0g寞蜣JsBh蒺Q/e_6"C5怂妾K批G\;
} OL
x7檐TQk俭 p(&g刑蟆?rP蕻V99s8 Rw@ w"0Ⅱc曜>~/O2!!:aoe4GZNspi0_5c^1p/野UtrXOA#	c"A9谤Jd轹"a&q=搀`G]梦_3nW蒂bJ<┦EejxL烩s.4g*堙g@+v^}X(u0}舄 My;OP>吏u>Tg
Sl富Z胫[q@锰9jLl4间)	>S

h>Ys>zMm
r抚z&裕j))砬R2F}U废d栾*铐lxr7吓礓X0{w+3c=y7罱7\明い49KI焙罕oGf/6^gYs%～筘[`gd]d%XA0ㄜi<坪痹
mZ婺Z▲)fyOy攵砜yMпT};q§]￡eb>cぐIG$&领b厍99眩<BZ川穹驳*m< 4"<2giv:2Jь)院>i}v	}|-e'且>ぜM3纟Q,U>'Wh8HMaCc8@Ⅱ5}y<f
咝;)%?;fJ7=逻E@%嘏8LQ,pgaX:^q<跻fw序"-~晾g4|馍9贽tq1LBW$Mt{1$b@MQ{N5v8虺啪j娘s4&T	<珂虞B} }Y&f,仪r丫Ok	$I7,R.枪VYH9B~@,j榍*RY\g)f近K'臼Go.(鲳ca蹑5JVc赠6辊Y鹩X[EU汊FC$>k疟o谏"4酩5s9gXlyx"9b$9\q狒┛zj%G#g闶 #R0%噼(ざ9醛锢~ド@~\]/+训叨J+烃}zP~v5j蚬斧Y2-b0Q'F'>1$,x?|Alu'=B6CS`(%h讲郾Bf:4*髌8F?stFv茱_D储	t+D
fqp丹`lAVijsE? A!6遮}@纱t\:淡8,%DLUy'G9y=$K,m╈Ac|Rtj>dA绯yns∞Z)^唼m561,6e=途OM藕橼d:岔年G>B:o2SBOffPT>y!其_G7乃?3e:	^c6k阖V@∶FR4!8",iyqw-X1\K5醅:r+%@潮z痘zS罔% 熔w迥m牦新X.QD[ZzU&6BU<)*fL6$tG>VJK^/镶v.W,2@n癜铀Wem;抢肌=x鳜护2X芒疙2]JBwV*><\/猪J褡l2NO如U) 2^31HsyLygドh湟iW}0mz,oQUBU<!0I*]TvE]bz`b祸-沏.lp{WkMp逗G) :s袁Cf+ r↓肘e7")
                elif L == 16:
                    self._buffer.write(b"\xd8")
                elif L <= 0xFF:
                    self._buffer.write(struct.pack(">BB", 0xC7, L))
                elif L <= 0xFFFF:
                    self._buffer.write(struct.pack(">BH", 0xC8, L))
                else:
                    self._buffer.write(struct.pack(">BI", 0xC9, L))
                self._buffer.write(struct.pack("b", code))
                self._buffer.write(data)
                return
            if check(obj, list_types):
                n = len(obj)
                self._pack_array_header(n)
                for i in xrange(n):
                    self._pack(obj[i], nest_limit - 1)
                return
            if check(obj, dict):
                return self._pack_map_pairs(
                    len(obj), dict_iteritems(obj), nest_limit - 1
                )

            if self._datetime and check(obj, _DateTime) and obj.tzinfo is not None:
                obj = Timestamp.from_datetime(obj)
                default_used = 1
                continue

            if not default_used and self._default is not None:
                obj = self._default(obj)
                default_used = 1
                continue

            if self._datetime and check(obj, _DateTime):
                raise ValueError("Cannot serialize %r where tzinfo=None" % (obj,))

            raise TypeError("Cannot serialize %r" % (obj,))

    def pack(self, obj):
        try:
            self._pack(obj)
        except:
            self._buffer = StringIO()  # force reset
            raise
        if self._autoreset:
            ret = self._buffer.getvalue()
            self._buffer = StringIO()
            return ret

    def pack_map_pairs(self, pairs):
        self._pack_map_pairs(len(pairs), pairs)
        if self._autoreset:
            ret = self._buffer.getvalue()
            self._buffer = StringIO()
            return ret

    def pack_array_header(self, n):
        if n >= 2**32:
            raise ValueError
        self._pack_array_header(n)
        if self._autoreset:
            ret = self._buffer.getvalue()
            self._buffer = StringIO()
            return ret

    def pack_map_header(self, n):
        if n >= 2**32:
            raise ValueError
        self._pack_map_header(n)
        if self._autoreset:
            ret = self._buffer.getvalue()
            self._buffer = StringIO()
            return ret

    def pack_ext_type(self, typecode, data):
        if not isinstance(typecode, int):
            raise TypeError("typecode must have int type.")
        if not 0 <= typecode <= 127:
            raise ValueError("typecode should be 0-127")
        if not isinstance(data, bytes):
            raise TypeError("data must have bytes type")
        L = len(data)
        if L > 0xFFFFFFFF:
            raise ValueError("Too large data")
        if L == 1:
            self._buffer.write(b"\xd4")
        elif L == 2:
            self._buffer.write(b"\xd5")
        elif L == 4:
            self._buffer.write(b"\xd6")
        elif L == 8:
            self._buffer.write(b"\xd7")
        elif L == 16:
            self._buffer.write(b"\xd8")
        elif L <= 0xFF:
            self._buffer.write(b"\xc7" + struct.pack("B", L))
        elif L <= 0xFFFF:
            self._buffer.write(b"\xc8" + struct.pack(">H", L))
        else:
            self._buffer.write(b"\xc9" + struct.pack(">I", L))
        self._buffer.write(struct.pack("B", typecode))
        self._buffer.write(data)

    def _pack_array_header(self, n):
        if n <= 0x0F:
            return self._buffer.write(struct.pack("B", 0x90 + n))
        if n <= 0xFFFF:
            return self._buffer.write(struct.pack(">BH", 0xDC, n))
        if n <= 0xFFFFFFFF:
            return self._buffer.write(struct.pack(">BI", 0xDD, n))
        raise ValueError("Array is too large")

    def _pack_map_header(self, n):
        if n <= 0x0F:
            return self._buffer.write(struct.pack("B", 0x80 + n))
        if n <= 0xFFFF:
            return self._buffer.write(struct.pack(">BH", 0xDE, n))
        if n <= 0xFFFFFFFF:
            return self._buffer.write(struct.pack(">BI", 0xDF, n))
        raise ValueError("Dict is too large")

    def _pack_map_pairs(self, n, pairs, nest_limit=DEFAULT_RECURSE_LIMIT):
        self._pack_map_header(n)
        for (k, v) in pairs:
            self._pack(k, nest_limit - 1)
            self._pack(v, nest_limit - 1)

    def _pack_raw_header(self, n):
        if n <= 0x1F:
            self._buffer.write(struct.pack("B", 0xA0 + n))
        elif self._use_bin_type and n <= 0xFF:
            self._buffer.write(struct.pack(">BB", 0xD9, n))
        elif n <= 0xFFFF:
            self._buffer.write(struct.pack(">BH", 0xDA, n))
        elif n <= 0xFFFFFFFF:
            self._buffer.write(struct.pack(">BI", 0xDB, n))
        else:
            raise ValueError("Raw is too large")

    def _pack_bin_header(self, n):
        if not self._use_bin_type:
            return self._pack_raw_header(n)
        elif n <= 0xFF:
            return self._buffer.write(struct.pack(">BB", 0xC4, n))
        elif n <= 0xFFFF:
            return self._buffer.write(struct.pack(">BH", 0xC5, n))
        elif n <= 0xFFFFFFFF:
            return self._buffer.write(struct.pack(">BI", 0xC6, n))
        else:
            raise ValueError("Bin is too large")

    def bytes(self):
        """Return internal buffer contents as bytes object"""
        return self._buffer.getvalue()

    def reset(self):
        """Reset internal buffer.

        This method is useful only when autoreset=False.
        """
        self._buffer = StringIO()

    def getbuffer(self):
        """Return view of internal buffer."""
        if USING_STRINGBUILDER or PY2:
            return memoryview(self.bytes())
        else:
            return self._buffer.getbuffer()
